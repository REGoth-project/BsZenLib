/**
 * Import zTEX-Texture
 * ===================
 *
 * This Module can convert a Gothic zTEX-Texture to a bs::Texture.
 *
 *
 * Texture files
 * -------------
 *
 * Gothic stores its textures in a proprietary format called ZTEX, which is basically DDS
 * with a different Header and some minor other modifications.
 *
 * Those ZTEX-files are generated by the game by converting TGA files, which can be seen as
 * caching mechanism. Therefore, in the other game files, the original TGA-name will be used.
 *
 * To still load the correct file, we have to convert the input filename of "SAMPLE.TGA" into
 * "SAMPLE-C.TEX", which is the compiled ZTEX file.
 *
 * In case there is no such compiled ZTEX file, we will try to load the original TGA file instead.
 */

#include "ImportTexture.hpp"
#include <Image/BsPixelData.h>
#include <Image/BsTexture.h>
#include <vdfs/fileIndex.h>
#include <zenload/ztex2dds.h>
#include <Image/BsColor.h>
#include <Resources/BsResources.h>
#include "ImportPath.hpp"
#include <FileSystem/BsFileSystem.h>

static std::vector<uint8_t> readCompiledTexture(const bs::String& path,
                                                const VDFS::FileIndex& vdfs);
static bs::String replaceExtension(const bs::String& path, const bs::String& newExtension);
static bs::HTexture createRGBA8Texture(const bs::String& name, bs::UINT32 width, bs::UINT32 height,
	const std::vector<uint8_t>& rgbaData);
static bs::HTexture createDXTnTexture(const bs::String& name,
	std::vector<uint8_t>& ddsData, const ZenLoad::DDSURFACEDESC2& surfaceDesc);

// - Implementation --------------------------------------------------------------------------------


bool BsZenLib::HasCachedTexture(const bs::String& virtualFilePath)
{
	using namespace bs;

	return FileSystem::isFile(GothicPathToCachedAsset(virtualFilePath.c_str()));
}

bs::HTexture BsZenLib::LoadCachedTexture(const bs::String& virtualFilePath)
{
	using namespace bs;

	Path path = GothicPathToCachedAsset(virtualFilePath.c_str());

	return gResources().load<Texture>(path);
}

bs::HTexture BsZenLib::ImportAndCacheTexture(const bs::String& virtualFilePath, const VDFS::FileIndex& vdfs)
{
	using namespace bs;

	gDebug().logDebug("Caching Texture: " + virtualFilePath);

	HTexture fromOriginal = ImportTexture(virtualFilePath, vdfs);

	if (!fromOriginal)
		return {};

	const bool overwrite = false;
	Path path = GothicPathToCachedAsset(virtualFilePath.c_str());

	gResources().save(fromOriginal, path, overwrite);

	return fromOriginal;
}

bs::HTexture BsZenLib::ImportTexture(const bs::String& path, const VDFS::FileIndex& vdfs)
{
  using namespace bs;

  std::vector<uint8_t> ztexData = readCompiledTexture(path, vdfs);

  if (ztexData.empty())
  {
    // TODO: Read uncompiled TGA
    return HTexture();
  }

  std::vector<uint8_t> ddsData;
  ZenLoad::convertZTEX2DDS(ztexData, ddsData);

  ZenLoad::DDSURFACEDESC2 surfaceDesc = ZenLoad::getSurfaceDesc(ddsData);

  return createDXTnTexture(path, ddsData, surfaceDesc);

  // Commented out: Optionally convert to RGBA8, which is easier to work with
  //std::vector<uint8_t> rgbaData;
  //ZenLoad::convertDDSToRGBA8(ddsData, rgbaData);
  //return createRGBA8Texture(surfaceDesc.dwWidth, surfaceDesc.dwHeight, rgbaData);
}


static bs::HTexture createRGBA8Texture(const bs::String& name, bs::UINT32 width, bs::UINT32 height,
                                       const std::vector<uint8_t>& rgbaData)
{
  using namespace bs;

  TEXTURE_DESC desc = {};
  desc.type = TEX_TYPE_2D;
  desc.width = width;
  desc.height = height;
  desc.format = PF_RGBA8;

  HTexture texture = Texture::create(desc);
  SPtr<PixelData> pixelData = PixelData::create(desc.width,   //
                                                desc.height,  //
                                                desc.depth,   //
                                                PixelFormat::PF_RGBA8);

  std::vector<Color> colors;
  size_t numPixels = desc.width * desc.height;

  assert(numPixels * 4 == rgbaData.size());

  for (size_t i = 0; i < numPixels; i++)
  {
    colors.emplace_back(rgbaData[0 + 4 * i] / 255.0f,   // R
                        rgbaData[1 + 4 * i] / 255.0f,   // G
                        rgbaData[2 + 4 * i] / 255.0f,   // B
                        rgbaData[3 + 4 * i] / 255.0f);  // A
  }

  pixelData->setColors(colors.data(), colors.size());

  texture->writeData(pixelData);
  texture->setName(name);

  return texture;
}

static bs::HTexture createDXTnTexture(const bs::String& name,
	std::vector<uint8_t>& ddsData, const ZenLoad::DDSURFACEDESC2& surfaceDesc)
{
	using namespace bs;

	TEXTURE_DESC desc = {};
	desc.type = TEX_TYPE_2D;
	desc.width = surfaceDesc.dwWidth;
	desc.height = surfaceDesc.dwHeight;
	desc.numMips = surfaceDesc.dwMipMapCount;

	switch (surfaceDesc.ddpfPixelFormat.dwFourCC)
	{
	case MAKEFOURCC('D', 'X', 'T', '1'):
		desc.format = PF_BC1;
		break;

	case MAKEFOURCC('D', 'X', 'T', '3'):
		desc.format = PF_BC2;
		break;

	case MAKEFOURCC('D', 'X', 'T', '5'):
		desc.format = PF_BC3;
		break;
	default:
		BS_EXCEPT(InternalErrorException, "Cannot import DXTn-texture " + name + ", unsupported FOURCC!")
	}

	HTexture texture = Texture::create(desc);

	for (size_t i = 0; i < surfaceDesc.dwMipMapCount; i++)
	{
		UINT32 mipWidth, mipHeight, mipDepth;
		PixelUtil::getSizeForMipLevel(desc.width, desc.height, 1, i, mipWidth, mipHeight, mipDepth);

		SPtr<PixelData> pixelData = PixelData::create(mipWidth,   //
			mipHeight,  //
			mipDepth,   //
			desc.format);

		size_t mipOffset = ZenLoad::getMipFileOffsetFromDDS(ddsData, i);

		UINT8* imageStart = (UINT8*)&ddsData[mipOffset];

		pixelData->setExternalBuffer(imageStart);

		texture->writeData(pixelData, 0, i);
	}

	texture->setName(name);

	return texture;
}


static std::vector<uint8_t> readCompiledTexture(const bs::String& path, const VDFS::FileIndex& vdfs)
{
	bs::String compiledFile = path;
	
	if (compiledFile.find(".TGA") != bs::String::npos)
	{
		compiledFile = replaceExtension(path, "-C.TEX");
	}

  std::vector<uint8_t> fileData;
  vdfs.getFileData(compiledFile.c_str(), fileData);

  return fileData;
}


static bs::String replaceExtension(const bs::String& path, const bs::String& newExtension)
{
  // assert(path.length() >= 4);

  if (path.length() < 4)
    return path;

  return path.substr(0, path.length() - 4) + newExtension;
}
